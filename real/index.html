<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced Gesture 3D Particle System</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; overflow: hidden; background: radial-gradient(ellipse at 30% 20%, #0b1020 0%, #05060c 55%, #000 100%); font-family: 'Inter', system-ui, sans-serif; }
    canvas { display: block; }
    #video-container { position: absolute; bottom: 16px; right: 16px; width: 260px; height: 195px; border: 2px solid rgba(255,255,255,0.15); border-radius: 16px; overflow: hidden; transform: scaleX(-1); backdrop-filter: blur(12px); box-shadow: 0 15px 50px rgba(0,0,0,0.5); }
    video { width: 100%; height: 100%; object-fit: cover; opacity: 0.9; }
    #hand-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    .glass { background: rgba(15, 23, 42, 0.65); border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 15px 50px rgba(0,0,0,0.4); backdrop-filter: blur(16px); }
    .hud-pill { background: linear-gradient(135deg, rgba(94,234,212,0.15), rgba(59,130,246,0.15)); border: 1px solid rgba(255,255,255,0.08); }
    .gesture-active { background: linear-gradient(135deg, rgba(16,185,129,0.3), rgba(6,182,212,0.3)); border-color: rgba(16,185,129,0.5); }
    .dot { width: 10px; height: 10px; border-radius: 9999px; }
    @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 20px rgba(16,185,129,0.3); } 50% { box-shadow: 0 0 40px rgba(16,185,129,0.6); } }
    .glow-pulse { animation: pulse-glow 2s infinite; }
    .gesture-icon { font-size: 1.5rem; transition: all 0.3s; }
    .gesture-icon.active { transform: scale(1.18); filter: drop-shadow(0 0 8px currentColor); }
    .fade { transition: opacity 0.35s ease; }
  </style>
</head>
<body>
  <!-- UI -->
  <div id="ui" class="absolute top-4 left-4 w-[380px] space-y-3 text-slate-100 select-none z-10 fade">
    <div class="glass rounded-2xl px-5 py-4">
      <div class="flex items-center justify-between">
        <div>
          <p class="uppercase text-xs tracking-[0.25em] text-cyan-400/80">Advanced</p>
          <h1 class="text-2xl font-bold bg-gradient-to-r from-cyan-300 to-purple-400 bg-clip-text text-transparent">Gesture Particles</h1>
        </div>
        <div id="status-badge" class="hud-pill px-3 py-2 rounded-xl text-xs font-semibold text-emerald-300 glow-pulse">‚óè Live</div>
      </div>
    </div>

    <div class="glass rounded-2xl px-5 py-4">
      <p class="text-xs text-slate-400 uppercase tracking-widest mb-3">Active Gestures</p>
      <div class="grid grid-cols-4 gap-2">
        <div id="g-palm" class="hud-pill rounded-xl p-3 text-center transition-all"><div class="gesture-icon">üñêÔ∏è</div><p class="text-xs mt-1 text-slate-300">Palm</p></div>
        <div id="g-fist" class="hud-pill rounded-xl p-3 text-center transition-all"><div class="gesture-icon">‚úä</div><p class="text-xs mt-1 text-slate-300">Fist</p></div>
        <div id="g-pinch" class="hud-pill rounded-xl p-3 text-center transition-all"><div class="gesture-icon">ü§è</div><p class="text-xs mt-1 text-slate-300">Pinch</p></div>
        <div id="g-peace" class="hud-pill rounded-xl p-3 text-center transition-all"><div class="gesture-icon">‚úåÔ∏è</div><p class="text-xs mt-1 text-slate-300">Peace</p></div>
        <div id="g-point" class="hud-pill rounded-xl p-3 text-center transition-all"><div class="gesture-icon">üëÜ</div><p class="text-xs mt-1 text-slate-300">Point</p></div>
        <div id="g-thumb" class="hud-pill rounded-xl p-3 text-center transition-all"><div class="gesture-icon">üëç</div><p class="text-xs mt-1 text-slate-300">Thumb</p></div>
        <div id="g-spread" class="hud-pill rounded-xl p-3 text-center transition-all"><div class="gesture-icon">üñêÔ∏è</div><p class="text-xs mt-1 text-slate-300">Spread</p></div>
        <div id="g-rotate" class="hud-pill rounded-xl p-3 text-center transition-all"><div class="gesture-icon">üîÑ</div><p class="text-xs mt-1 text-slate-300">Rotate</p></div>
      </div>
    </div>

    <div class="glass rounded-2xl px-5 py-4 space-y-3">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-2"><span class="dot bg-cyan-400/80 animate-pulse"></span><p class="text-sm">Template</p></div>
        <p id="mode-text" class="text-lg font-bold tracking-wide text-cyan-300">Sphere</p>
      </div>
      <div class="grid grid-cols-4 gap-2 text-xs text-slate-200">
        <div class="hud-pill px-3 py-2 rounded-xl text-center"><span class="block text-slate-400">Particles</span><span id="stat-count" class="font-semibold">10000</span></div>
        <div class="hud-pill px-3 py-2 rounded-xl text-center"><span class="block text-slate-400">FPS</span><span id="stat-fps" class="font-semibold">--</span></div>
        <div class="hud-pill px-3 py-2 rounded-xl text-center"><span class="block text-slate-400">Gesture</span><span id="stat-gesture" class="font-semibold">None</span></div>
        <div class="hud-pill px-3 py-2 rounded-xl text-center"><span class="block text-slate-400">Velocity</span><span id="stat-velocity" class="font-semibold">0</span></div>
      </div>
      <div class="hud-pill rounded-xl px-4 py-3">
        <div class="flex justify-between text-xs text-slate-300">
          <span>Hand X: <span id="hand-x" class="text-cyan-300">0.00</span></span>
          <span>Hand Y: <span id="hand-y" class="text-cyan-300">0.00</span></span>
          <span>Depth: <span id="hand-z" class="text-cyan-300">0.00</span></span>
        </div>
      </div>
    </div>

    <div class="glass rounded-2xl px-5 py-4 space-y-3">
      <div class="flex items-center justify-between text-sm">
        <div class="flex items-center gap-2"><div class="dot bg-purple-400"></div><span>Auto-rotate</span></div>
        <label class="inline-flex items-center cursor-pointer"><input id="toggle-rotate" type="checkbox" class="sr-only peer" checked><div class="w-11 h-6 bg-slate-700 rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-500 relative"></div></label>
      </div>
      <div class="flex items-center justify-between text-sm">
        <div class="flex items-center gap-2"><div class="dot bg-amber-400"></div><span>Show Trails</span></div>
        <label class="inline-flex items-center cursor-pointer"><input id="toggle-trails" type="checkbox" class="sr-only peer"><div class="w-11 h-6 bg-slate-700 rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-amber-500 relative"></div></label>
      </div>
      <div class="flex items-center justify-between text-sm">
        <div class="flex items-center gap-2"><div class="dot bg-rose-400"></div><span>Hand Skeleton</span></div>
        <label class="inline-flex items-center cursor-pointer"><input id="toggle-skeleton" type="checkbox" class="sr-only peer" checked><div class="w-11 h-6 bg-slate-700 rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-rose-500 relative"></div></label>
      </div>
      <div>
        <label class="text-xs text-slate-400">Particle Size <span id="size-label" class="text-slate-200">0.09</span></label>
        <input id="size-slider" type="range" min="0.02" max="0.3" step="0.01" value="0.09" class="w-full accent-cyan-400">
      </div>
      <div>
        <label class="text-xs text-slate-400">Sensitivity <span id="sens-label" class="text-slate-200">1.0</span></label>
        <input id="sens-slider" type="range" min="0.3" max="2.0" step="0.1" value="1.0" class="w-full accent-purple-400">
      </div>
      <div class="flex gap-2"><button id="prev-btn" class="flex-1 bg-slate-800/70 hover:bg-slate-700 transition rounded-xl py-2 text-sm">‚óÄ Prev</button><button id="next-btn" class="flex-1 bg-slate-800/70 hover:bg-slate-700 transition rounded-xl py-2 text-sm">Next ‚ñ∂</button></div>
      <div class="flex gap-2"><button id="explode-btn" class="flex-1 bg-gradient-to-r from-orange-600/50 to-red-600/50 hover:from-orange-500/60 hover:to-red-500/60 transition rounded-xl py-2 text-sm">üí• Explode</button><button id="implode-btn" class="flex-1 bg-gradient-to-r from-blue-600/50 to-purple-600/50 hover:from-blue-500/60 hover:to-purple-500/60 transition rounded-xl py-2 text-sm">üåÄ Implode</button></div>
    </div>

    <div class="glass rounded-2xl px-5 py-3 text-xs text-slate-400">
      <p><span class="text-slate-200">Space</span>: Pause | <span class="text-slate-200">‚Üê/‚Üí</span>: Cycle | <span class="text-slate-200">C</span>: Colors | <span class="text-slate-200">E</span>: Explode | <span class="text-slate-200">R</span>: Reset</p>
    </div>
  </div>

  <div id="video-container" class="fade">
    <video id="input-video" playsinline></video>
    <canvas id="hand-canvas"></canvas>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    const PARTICLE_COUNT = 11000;
    const modes = ['sphere', 'heart', 'saturn', 'fireworks', 'torus', 'spiral', 'galaxy', 'dna', 'cube', 'wave'];
    let currentTemplate = 'sphere';
    let isPaused = false;
    let autoRotate = true;
    let showTrails = false;
    let showSkeleton = true;
    let sensitivity = 1.0;

    // Hand tracking state
    let rawHandX = 0, rawHandY = 0, rawHandZ = 0;
    let handX = 0, handY = 0, handZ = 0;
    let handVelX = 0, handVelY = 0;
    let prevHandX = 0, prevHandY = 0;
    const smoothingFactor = 0.18;
    const clamp = (v, min, max) => Math.min(Math.max(v, min), max);

    // Gesture states
    let gestures = { palm: false, fist: false, pinch: false, peace: false, point: false, thumbUp: false, spread: false, rotate: false };
    let currentGesture = 'none';
    let lastSwitchTime = 0;
    let lastFrame = performance.now();
    let fps = 0;

    // Effect states
    let explosionForce = 0;
    let implosionForce = 0;
    let manualRotationX = 0, manualRotationY = 0;

    let currentLandmarks = null;
    let currentHandedness = 'Right';

    // UI references
    const modeText = document.getElementById('mode-text');
    const statCount = document.getElementById('stat-count');
    const statFps = document.getElementById('stat-fps');
    const statGesture = document.getElementById('stat-gesture');
    const statVelocity = document.getElementById('stat-velocity');
    const handXEl = document.getElementById('hand-x');
    const handYEl = document.getElementById('hand-y');
    const handZEl = document.getElementById('hand-z');
    const sizeSlider = document.getElementById('size-slider');
    const sizeLabel = document.getElementById('size-label');
    const sensSlider = document.getElementById('sens-slider');
    const sensLabel = document.getElementById('sens-label');
    const toggleRotate = document.getElementById('toggle-rotate');
    const toggleTrails = document.getElementById('toggle-trails');
    const toggleSkeleton = document.getElementById('toggle-skeleton');
    const handCanvas = document.getElementById('hand-canvas');
    const handCtx = handCanvas.getContext('2d');

    const gestureElements = {
      palm: document.getElementById('g-palm'),
      fist: document.getElementById('g-fist'),
      pinch: document.getElementById('g-pinch'),
      peace: document.getElementById('g-peace'),
      point: document.getElementById('g-point'),
      thumbUp: document.getElementById('g-thumb'),
      spread: document.getElementById('g-spread'),
      rotate: document.getElementById('g-rotate')
    };

    document.getElementById('prev-btn').onclick = () => switchMode(-1);
    document.getElementById('next-btn').onclick = () => switchMode(1);
    document.getElementById('explode-btn').onclick = () => { explosionForce = 15; };
    document.getElementById('implode-btn').onclick = () => { implosionForce = 0.18; };
    toggleRotate.onchange = (e) => { autoRotate = e.target.checked; };
    toggleTrails.onchange = (e) => { showTrails = e.target.checked; };
    toggleSkeleton.onchange = (e) => { showSkeleton = e.target.checked; };
    sizeSlider.oninput = (e) => { material.size = parseFloat(e.target.value); sizeLabel.textContent = e.target.value; };
    sensSlider.oninput = (e) => { sensitivity = parseFloat(e.target.value); sensLabel.textContent = e.target.value; };

    // THREE.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 18;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // Particles
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const velocities = new Float32Array(PARTICLE_COUNT * 3);
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const i3 = i * 3;
      positions[i3] = (Math.random() - 0.5) * 20;
      positions[i3 + 1] = (Math.random() - 0.5) * 20;
      positions[i3 + 2] = (Math.random() - 0.5) * 20;
      velocities[i3] = velocities[i3 + 1] = velocities[i3 + 2] = 0;
      const hue = Math.random() * 0.25 + 0.55;
      const c = new THREE.Color().setHSL(hue, 0.85, 0.6);
      colors[i3] = c.r; colors[i3 + 1] = c.g; colors[i3 + 2] = c.b;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: parseFloat(sizeSlider.value),
      vertexColors: true,
      transparent: true,
      opacity: 0.92,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });
    const points = new THREE.Points(geometry, material);
    scene.add(points);
    scene.fog = new THREE.FogExp2('#050510', 0.03);

    // Shape generator
    function getTemplatePosition(index, type, time = 0) {
      const i = index / PARTICLE_COUNT;
      const t = i * Math.PI * 2;
      const u = (index % 120) / 120 * Math.PI * 2;
      const v = Math.floor(index / 120) / (PARTICLE_COUNT / 120) * Math.PI;
      switch (type) {
        case 'heart': {
          const scale = 0.35;
          const x = 16 * Math.pow(Math.sin(t * 8), 3);
          const y = 13 * Math.cos(t * 8) - 5 * Math.cos(2 * t * 8) - 2 * Math.cos(3 * t * 8) - Math.cos(4 * t * 8);
          return { x: x * scale, y: y * scale + 1, z: Math.sin(t * 16) * 2 };
        }
        case 'saturn': {
          if (index < PARTICLE_COUNT * 0.6) {
            const r = 5.6;
            return { x: r * Math.sin(v) * Math.cos(u), y: r * Math.sin(v) * Math.sin(u), z: r * Math.cos(v) };
          } else {
            const ringR = 7.5 + (index % 80) * 0.04;
            const angle = t * 70 + time * 0.5;
            return { x: ringR * Math.cos(angle), y: ringR * Math.sin(angle) * 0.12, z: ringR * Math.sin(angle) };
          }
        }
        case 'fireworks': {
          const burst = index % 5;
          const speed = 4 + (index % 25) * 0.11;
          const bx = (burst - 2) * 4.5;
          return { x: bx + Math.cos(t * 150) * speed, y: Math.sin(t * 150) * speed, z: Math.sin(u * 12) * speed };
        }
        case 'torus': {
          const R = 6.2, r = 2.6;
          return { x: (R + r * Math.cos(v)) * Math.cos(u), y: (R + r * Math.cos(v)) * Math.sin(u), z: r * Math.sin(v) };
        }
        case 'spiral': {
          const turns = 8.5;
          const radius = 1.5 + i * 7.5;
          const height = (i - 0.5) * 15;
          return { x: Math.cos(t * turns) * radius, y: height, z: Math.sin(t * turns) * radius };
        }
        case 'galaxy': {
          const arm = index % 4;
          const armOffset = (arm / 4) * Math.PI * 2;
          const dist = i * 10.5;
          const twist = dist * 0.5 + armOffset;
          const spread = Math.random() * 1.4;
          return {
            x: Math.cos(twist) * dist + Math.random() * spread,
            y: (Math.random() - 0.5) * 1.2 * (1 - i),
            z: Math.sin(twist) * dist + Math.random() * spread
          };
        }
        case 'dna': {
          const height = (i - 0.5) * 20;
          const twist = i * Math.PI * 8 + time * 1.2;
          const radius = 3.2;
          return index % 2 === 0
            ? { x: Math.cos(twist) * radius, y: height, z: Math.sin(twist) * radius }
            : { x: Math.cos(twist + Math.PI) * radius, y: height, z: Math.sin(twist + Math.PI) * radius };
        }
        case 'cube': {
          const size = 6.4;
          const face = index % 6;
          const fi = (index / 6) / (PARTICLE_COUNT / 6);
          const fx = (fi % 1) * 2 - 1;
          const fy = (Math.floor(fi * 60) / 60) * 2 - 1;
          switch (face) {
            case 0: return { x: fx * size, y: fy * size, z: size };
            case 1: return { x: fx * size, y: fy * size, z: -size };
            case 2: return { x: size, y: fx * size, z: fy * size };
            case 3: return { x: -size, y: fx * size, z: fy * size };
            case 4: return { x: fx * size, y: size, z: fy * size };
            default: return { x: fx * size, y: -size, z: fy * size };
          }
        }
        case 'wave': {
          const gridSize = Math.ceil(Math.sqrt(PARTICLE_COUNT));
          const gx = (index % gridSize) / gridSize * 20 - 10;
          const gz = Math.floor(index / gridSize) / gridSize * 20 - 10;
          const gy = Math.sin(gx * 0.45 + time * 2.2) * Math.cos(gz * 0.45 + time * 2.2) * 3.2;
          return { x: gx, y: gy, z: gz };
        }
        default: {
          const r = 7.5;
          return { x: r * Math.sin(v) * Math.cos(u), y: r * Math.sin(v) * Math.sin(u), z: r * Math.cos(v) };
        }
      }
    }

    // Gesture stability buffers
    const gestureFrames = { palm: 0, fist: 0, pinch: 0, peace: 0, point: 0, thumbUp: 0, spread: 0, rotate: 0 };
    const gestureThreshold = 4; // frames required

    function detectGestures(landmarks, handedness = 'Right') {
      const tips = [4, 8, 12, 16, 20];
      const pips = [3, 6, 10, 14, 18];
      const mcps = [2, 5, 9, 13, 17];
      const dist = (a, b) => Math.hypot(landmarks[a].x - landmarks[b].x, landmarks[a].y - landmarks[b].y);
      const isExtended = (tipIdx, pipIdx, mcpIdx) => {
        const tipY = landmarks[tips[tipIdx]].y;
        const pipY = landmarks[pips[tipIdx]].y;
        const mcpY = landmarks[mcps[tipIdx]].y;
        return tipY < pipY && pipY < mcpY - 0.01;
      };

      // thumb orientation adjusts for left/right
      const thumbExtended = handedness === 'Right'
        ? landmarks[4].x < landmarks[3].x - 0.015
        : landmarks[4].x > landmarks[3].x + 0.015;
      const indexExtended = isExtended(1, 1, 1);
      const middleExtended = isExtended(2, 2, 2);
      const ringExtended = isExtended(3, 3, 3);
      const pinkyExtended = isExtended(4, 4, 4);

      const pinchDist = dist(4, 8);
      const fingerSpread = dist(8, 12) + dist(12, 16) + dist(16, 20);

      const newGestures = {
        pinch: pinchDist < 0.05,
        fist: !indexExtended && !middleExtended && !ringExtended && !pinkyExtended,
        peace: indexExtended && middleExtended && !ringExtended && !pinkyExtended,
        point: indexExtended && !middleExtended && !ringExtended && !pinkyExtended,
        thumbUp: thumbExtended && !indexExtended && !middleExtended && !ringExtended && !pinkyExtended,
        spread: indexExtended && middleExtended && ringExtended && pinkyExtended && fingerSpread > 0.24,
        palm: indexExtended && middleExtended && ringExtended && pinkyExtended && fingerSpread <= 0.24,
        rotate: false
      };

      // rotation: measure palm orientation roll via cross product
      const palmNormal = (() => {
        const a = landmarks[0], b = landmarks[5], c = landmarks[17];
        const ab = { x: b.x - a.x, y: b.y - a.y, z: b.z - a.z };
        const ac = { x: c.x - a.x, y: c.y - a.y, z: c.z - a.z };
        return {
          x: ab.y * ac.z - ab.z * ac.y,
          y: ab.z * ac.x - ab.x * ac.z,
          z: ab.x * ac.y - ab.y * ac.x
        };
      })();
      const roll = Math.atan2(palmNormal.y, palmNormal.x);
      newGestures.rotate = Math.abs(roll) > 0.45 && newGestures.fist;

      // Stabilize by counting frames
      Object.keys(newGestures).forEach(key => {
        gestureFrames[key] = newGestures[key] ? Math.min(gestureFrames[key] + 1, gestureThreshold + 2) : 0;
        gestures[key] = gestureFrames[key] >= gestureThreshold;
      });

      // Primary gesture priority
      if (gestures.pinch) currentGesture = 'pinch';
      else if (gestures.thumbUp) currentGesture = 'thumbUp';
      else if (gestures.peace) currentGesture = 'peace';
      else if (gestures.point) currentGesture = 'point';
      else if (gestures.fist) currentGesture = 'fist';
      else if (gestures.spread) currentGesture = 'spread';
      else if (gestures.palm) currentGesture = 'palm';
      else currentGesture = 'none';

      Object.keys(gestureElements).forEach(key => {
        const el = gestureElements[key];
        const active = gestures[key];
        el.classList.toggle('gesture-active', active);
        el.querySelector('.gesture-icon').classList.toggle('active', active);
      });
      return currentGesture;
    }

    function drawHandSkeleton(landmarks) {
      if (!showSkeleton || !landmarks) return;
      handCanvas.width = handCanvas.offsetWidth;
      handCanvas.height = handCanvas.offsetHeight;
      handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
      const connections = [
        [0, 1], [1, 2], [2, 3], [3, 4],
        [0, 5], [5, 6], [6, 7], [7, 8],
        [0, 9], [9, 10], [10, 11], [11, 12],
        [0, 13], [13, 14], [14, 15], [15, 16],
        [0, 17], [17, 18], [18, 19], [19, 20],
        [5, 9], [9, 13], [13, 17]
      ];
      handCtx.strokeStyle = 'rgba(0, 255, 200, 0.7)';
      handCtx.lineWidth = 2;
      connections.forEach(([a, b]) => {
        handCtx.beginPath();
        handCtx.moveTo(landmarks[a].x * handCanvas.width, landmarks[a].y * handCanvas.height);
        handCtx.lineTo(landmarks[b].x * handCanvas.width, landmarks[b].y * handCanvas.height);
        handCtx.stroke();
      });
      landmarks.forEach((lm, idx) => {
        const x = lm.x * handCanvas.width;
        const y = lm.y * handCanvas.height;
        const isTip = [4, 8, 12, 16, 20].includes(idx);
        const radius = isTip ? 5 : 3;
        handCtx.beginPath();
        handCtx.arc(x, y, radius, 0, Math.PI * 2);
        handCtx.fillStyle = isTip ? '#00ffcc' : '#ffffff';
        handCtx.fill();
      });
    }

    const videoElement = document.getElementById('input-video');
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.65, minTrackingConfidence: 0.65 });
    hands.onResults((results) => {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        currentLandmarks = landmarks;
        currentHandedness = results.multiHandedness ? results.multiHandedness[0].label || 'Right' : 'Right';
        const palmCenter = landmarks[9];
        const handSize = Math.hypot(landmarks[0].x - landmarks[12].x, landmarks[0].y - landmarks[12].y);
        rawHandX = (0.5 - palmCenter.x) * (currentHandedness === 'Right' ? 1 : -1) * 28 * sensitivity;
        rawHandY = (0.5 - palmCenter.y) * 22 * sensitivity;
        rawHandZ = (0.28 - handSize) * 48;
        handX += (rawHandX - handX) * smoothingFactor;
        handY += (rawHandY - handY) * smoothingFactor;
        handZ += (rawHandZ - handZ) * smoothingFactor;
        handX = clamp(handX, -12, 12);
        handY = clamp(handY, -10, 10);
        handZ = clamp(handZ, -20, 20);
        handVelX = handX - prevHandX;
        handVelY = handY - prevHandY;
        prevHandX = handX; prevHandY = handY;
        const gesture = detectGestures(landmarks, currentHandedness);
        const now = Date.now();
        if (gestures.pinch && now - lastSwitchTime > 900) { switchMode(1); lastSwitchTime = now; }
        if (gestures.spread) explosionForce = Math.max(explosionForce, 7.2);
        if (gestures.thumbUp) shuffleColors();
        if (gestures.peace) { manualRotationY += handVelX * 0.02; manualRotationX += handVelY * 0.02; }
        drawHandSkeleton(landmarks);
        statGesture.textContent = gesture === 'none' ? 'None' : gesture;
        handXEl.textContent = handX.toFixed(2);
        handYEl.textContent = handY.toFixed(2);
        handZEl.textContent = handZ.toFixed(2);
        statVelocity.textContent = Math.sqrt(handVelX * handVelX + handVelY * handVelY).toFixed(2);
        document.getElementById('ui').style.opacity = 1;
        document.getElementById('video-container').style.opacity = 1;
      } else {
        currentLandmarks = null;
        handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
        statGesture.textContent = 'No Hand';
        Object.values(gestureElements).forEach(el => { el.classList.remove('gesture-active'); el.querySelector('.gesture-icon').classList.remove('active'); });
        document.getElementById('ui').style.opacity = 0.45;
        document.getElementById('video-container').style.opacity = 0.3;
      }
    });

    const cameraFeed = new Camera(videoElement, { onFrame: async () => { await hands.send({ image: videoElement }); }, width: 640, height: 480 });
    cameraFeed.start();

    function switchMode(delta) {
      const idx = (modes.indexOf(currentTemplate) + delta + modes.length) % modes.length;
      currentTemplate = modes[idx];
      modeText.textContent = currentTemplate.charAt(0).toUpperCase() + currentTemplate.slice(1);
    }

    let lastColorShuffle = 0;
    function shuffleColors() {
      const now = Date.now();
      if (now - lastColorShuffle < 500) return;
      lastColorShuffle = now;
      const colAttr = geometry.attributes.color;
      const baseHue = Math.random();
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const hue = (baseHue + Math.random() * 0.3) % 1;
        const c = new THREE.Color().setHSL(hue, 0.85, 0.55);
        colAttr.array[i * 3] = c.r;
        colAttr.array[i * 3 + 1] = c.g;
        colAttr.array[i * 3 + 2] = c.b;
      }
      colAttr.needsUpdate = true;
    }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'ArrowRight') switchMode(1);
      if (e.code === 'ArrowLeft') switchMode(-1);
      if (e.code === 'Space') { isPaused = !isPaused; e.preventDefault(); }
      if (e.key.toLowerCase() === 'c') shuffleColors();
      if (e.key.toLowerCase() === 'e') explosionForce = 15;
      if (e.key.toLowerCase() === 'r') { explosionForce = 0; implosionForce = 0; manualRotationX = 0; manualRotationY = 0; points.rotation.set(0, 0, 0); }
    });

    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const delta = (now - lastFrame) / 1000;
      fps = Math.round(1 / delta);
      lastFrame = now;
      statFps.textContent = fps;
      if (isPaused) { renderer.render(scene, camera); return; }
      const posAttr = geometry.attributes.position;
      const colAttr = geometry.attributes.color;
      const time = now * 0.001;
      explosionForce *= 0.96;
      implosionForce *= 0.97;
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        const target = getTemplatePosition(i, currentTemplate, time);
        let px = posAttr.array[i3];
        let py = posAttr.array[i3 + 1];
        let pz = posAttr.array[i3 + 2];
        let tx = target.x, ty = target.y, tz = target.z;
        let lerp = 0.045;
        if (gestures.fist) { tx = handX; ty = handY; tz = handZ * 0.4; lerp = 0.12; }
        else if (gestures.point) { tx += handX * 0.25; ty += handY * 0.25; lerp = 0.065; }
        else if (gestures.palm) {
          const dx = px - handX, dy = py - handY; const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
          const push = Math.max(0, 5 - dist) * 0.35; tx += (dx / dist) * push; ty += (dy / dist) * push;
        }
        if (explosionForce > 0.1) {
          const dx = px, dy = py, dz = pz; const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.1;
          velocities[i3] += (dx / dist) * explosionForce * 0.02;
          velocities[i3 + 1] += (dy / dist) * explosionForce * 0.02;
          velocities[i3 + 2] += (dz / dist) * explosionForce * 0.02;
        }
        if (implosionForce > 0.01) {
          velocities[i3] -= px * implosionForce * 0.9;
          velocities[i3 + 1] -= py * implosionForce * 0.9;
          velocities[i3 + 2] -= pz * implosionForce * 0.9;
        }
        velocities[i3] *= 0.945; velocities[i3 + 1] *= 0.945; velocities[i3 + 2] *= 0.945;
        posAttr.array[i3] += (tx - px) * lerp + velocities[i3];
        posAttr.array[i3 + 1] += (ty - py) * lerp + velocities[i3 + 1];
        posAttr.array[i3 + 2] += (tz - pz) * lerp + velocities[i3 + 2];
        // Soft boundary to prevent drifting off screen
        const bound = 24;
        posAttr.array[i3] = clamp(posAttr.array[i3], -bound, bound);
        posAttr.array[i3 + 1] = clamp(posAttr.array[i3 + 1], -bound, bound);
        posAttr.array[i3 + 2] = clamp(posAttr.array[i3 + 2], -bound, bound);
        const depth = THREE.MathUtils.clamp((posAttr.array[i3 + 2] + 10) / 20, 0, 1);
        let hue = (time * 0.05 + depth * 0.4 + i * 0.00001) % 1;
        if (gestures.fist) hue = (hue + 0.1) % 1;
        if (gestures.spread) hue = (hue + 0.5) % 1;
        const saturation = gestures.point ? 1.0 : 0.82;
        const lightness = 0.5 + 0.2 * Math.sin(time * 2 + i * 0.003);
        const c = new THREE.Color().setHSL(hue, saturation, lightness);
        colAttr.array[i3] = c.r; colAttr.array[i3 + 1] = c.g; colAttr.array[i3 + 2] = c.b;
      }
      posAttr.needsUpdate = true; colAttr.needsUpdate = true;
      if (autoRotate) { points.rotation.y += 0.004; points.rotation.x += 0.001; }
      points.rotation.x += manualRotationX * 0.1; points.rotation.y += manualRotationY * 0.1; manualRotationX *= 0.92; manualRotationY *= 0.92;
      if (showTrails) { renderer.autoClearColor = false; renderer.setClearColor(0x000000, 0.1); renderer.clear(); } else { renderer.autoClearColor = true; }
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    statCount.textContent = PARTICLE_COUNT.toLocaleString();
    animate();
  </script>
</body>
</html>
